using System.Collections.Generic;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Input;
using System.Windows.Media;

namespace Nodify
{
    /// <summary>
    /// Delegate used to notify when an <see cref="ItemContainer"/> is previewing a new location.
    /// </summary>
    /// <param name="newLocation">The new location.</param>
    public delegate void PreviewLocationChanged(Point newLocation);

    /// <summary>
    /// The container for all the items generated by the <see cref="ItemsControl.ItemsSource"/> of the <see cref="NodifyEditor"/>.
    /// </summary>
    public partial class ItemContainer : ContentControl, INodifyCanvasItem, ISelectable
    {
        #region Dependency Properties

        public static readonly StyledProperty<IBrush> HighlightBrushProperty = AvaloniaProperty.Register<ItemContainer, IBrush>(nameof(HighlightBrush));
        public static readonly StyledProperty<IBrush> SelectedBrushProperty = AvaloniaProperty.Register<ItemContainer, IBrush>(nameof(SelectedBrush));
        public static readonly StyledProperty<Thickness> SelectedBorderThicknessProperty = AvaloniaProperty.Register<ItemContainer, Thickness>(nameof(SelectedBorderThickness), BoxValue.Thickness2);
        public static readonly StyledProperty<bool> IsSelectableProperty = AvaloniaProperty.Register<ItemContainer, bool>(nameof(IsSelectable), BoxValue.True);
        public static readonly StyledProperty<bool> IsSelectedProperty = SelectingItemsControl.IsSelectedProperty.AddOwner<ItemContainer>();
        public static readonly DirectProperty<ItemContainer, bool?> IsPreviewingSelectionProperty = AvaloniaProperty.RegisterDirect<ItemContainer, bool?>(nameof(IsPreviewingSelection), x => x.IsPreviewingSelection);
        public static readonly StyledProperty<Point> LocationProperty = AvaloniaProperty.Register<ItemContainer, Point>(nameof(Location), BoxValue.Point, defaultBindingMode: BindingMode.TwoWay);
        public static readonly StyledProperty<Size> ActualSizeProperty = AvaloniaProperty.Register<ItemContainer, Size>(nameof(ActualSize), BoxValue.Size);
        public static readonly StyledProperty<Size?> DesiredSizeForSelectionProperty = AvaloniaProperty.Register<ItemContainer, Size?>(nameof(DesiredSizeForSelection), null); //, FrameworkPropertyMetadataOptions.NotDataBindable);
        public static readonly DirectProperty<ItemContainer, bool> IsPreviewingLocationProperty = AvaloniaProperty.RegisterDirect<ItemContainer, bool>(nameof(IsPreviewingLocation), x => x.IsPreviewingLocation);
        public static readonly StyledProperty<bool> IsDraggableProperty = AvaloniaProperty.Register<ItemContainer, bool>(nameof(IsDraggable), BoxValue.True);

        /// <summary>
        /// Gets or sets the brush used when the <see cref="PendingConnection.IsOverElementProperty"/> attached property is true for this <see cref="ItemContainer"/>.
        /// </summary>
        public IBrush HighlightBrush
        {
            get => (IBrush)GetValue(HighlightBrushProperty);
            set => SetValue(HighlightBrushProperty, value);
        }

        /// <summary>
        /// Gets or sets the brush used when <see cref="IsSelected"/> or <see cref="IsPreviewingSelection"/> is true.
        /// </summary>
        public IBrush SelectedBrush
        {
            get => (IBrush)GetValue(SelectedBrushProperty);
            set => SetValue(SelectedBrushProperty, value);
        }

        /// <summary>
        /// Gets or sets the border thickness used when <see cref="IsSelected"/> or <see cref="IsPreviewingSelection"/> is true.
        /// </summary>
        public Thickness SelectedBorderThickness
        {
            get => (Thickness)GetValue(SelectedBorderThicknessProperty);
            set => SetValue(SelectedBorderThicknessProperty, value);
        }

        /// <summary>
        /// Gets or sets the location of this <see cref="ItemContainer"/> inside the <see cref="NodifyEditor"/> in graph space coordinates.
        /// </summary>
        public Point Location
        {
            get => (Point)GetValue(LocationProperty);
            set => SetValue(LocationProperty, value);
        }

        /// <summary>
        /// Gets or sets a value that indicates whether this <see cref="ItemContainer"/> is selected.
        /// Can only be set if <see cref="IsSelectable"/> is true.
        /// </summary>
        public bool IsSelected
        {
            get => (bool)GetValue(IsSelectedProperty);
            set => SetValue(IsSelectedProperty, value);
        }

        private bool? isPreviewingSelection;
        /// <summary>
        /// Gets a value indicating whether this <see cref="ItemContainer"/> is about to change its <see cref="IsSelected"/> state.
        /// </summary>
        public bool? IsPreviewingSelection
        {
            get => isPreviewingSelection;
            internal set => SetAndRaise(IsPreviewingSelectionProperty, ref isPreviewingSelection, value);
        }

        /// <summary>
        /// Gets or sets whether this <see cref="ItemContainer"/> can be selected.
        /// </summary>
        public bool IsSelectable
        {
            get => (bool)GetValue(IsSelectableProperty);
            set => SetValue(IsSelectableProperty, value);
        }

        private bool isPreviewingLocation;
        /// <summary>
        /// Gets a value indicating whether this <see cref="ItemContainer"/> is previewing a new location but didn't logically move there.
        /// </summary>
        public bool IsPreviewingLocation
        {
            get => isPreviewingLocation;
            internal set => SetAndRaise(IsPreviewingLocationProperty, ref isPreviewingLocation, value);
        }

        /// <summary>
        /// Gets the actual size of this <see cref="ItemContainer"/>.
        /// </summary>
        public Size ActualSize
        {
            get => (Size)GetValue(ActualSizeProperty);
            set => SetValue(ActualSizeProperty, value);
        }

        /// <summary>
        /// Overrides the size to check against when calculating if this <see cref="ItemContainer"/> can be part of the current <see cref="NodifyEditor.SelectedArea"/>.
        /// Defaults to <see cref="UIElement.RenderSize"/>.
        /// </summary>
        public Size? DesiredSizeForSelection
        {
            get => (Size?)GetValue(DesiredSizeForSelectionProperty);
            set => SetValue(DesiredSizeForSelectionProperty, value);
        }

        /// <summary>
        /// Gets or sets whether this <see cref="ItemContainer"/> can be dragged.
        /// </summary>
        public bool IsDraggable
        {
            get => (bool)GetValue(IsDraggableProperty);
            set => SetValue(IsDraggableProperty, value);
        }

        private static void OnLocationChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            var item = (ItemContainer)d;
            item.OnLocationChanged();

            if (!item.Editor.IsBulkUpdatingItems)
            {
                item.Editor.ItemsHost.InvalidateArrange();
            }
        }

        #endregion

        #region Routed Events

        public static readonly RoutedEvent<DragStartedEventArgs> DragStartedEvent = RoutedEvent.Register<DragStartedEventArgs>(nameof(DragStarted), RoutingStrategies.Bubble, typeof(ItemContainer));
        public static readonly RoutedEvent<DragCompletedEventArgs> DragCompletedEvent = RoutedEvent.Register<DragCompletedEventArgs>(nameof(DragCompleted), RoutingStrategies.Bubble, typeof(ItemContainer));
        public static readonly RoutedEvent<DragDeltaEventArgs> DragDeltaEvent = RoutedEvent.Register<DragDeltaEventArgs>(nameof(DragDelta), RoutingStrategies.Bubble, typeof(ItemContainer));
        public static readonly RoutedEvent<RoutedEventArgs> SelectedEvent = RoutedEvent.Register<RoutedEventArgs>(nameof(Selected), RoutingStrategies.Bubble, typeof(ItemContainer));
        public static readonly RoutedEvent<RoutedEventArgs> UnselectedEvent = RoutedEvent.Register<RoutedEventArgs>(nameof(Unselected), RoutingStrategies.Bubble, typeof(ItemContainer));
        public static readonly RoutedEvent<RoutedEventArgs> LocationChangedEvent = RoutedEvent.Register<RoutedEventArgs>(nameof(LocationChanged), RoutingStrategies.Bubble, typeof(ItemContainer));

        /// <summary>
        /// Occurs when the <see cref="Location"/> of this <see cref="ItemContainer"/> is changed.
        /// </summary>
        public event RoutedEventHandler LocationChanged
        {
            add => AddHandler(LocationChangedEvent, value);
            remove => RemoveHandler(LocationChangedEvent, value);
        }

        /// <summary>
        /// Occurs when this <see cref="ItemContainer"/> is the instigator of a drag operation.
        /// </summary>
        public event EventHandler<DragEventArgs> DragStarted
        {
            add => AddHandler(DragStartedEvent, value);
            remove => RemoveHandler(DragStartedEvent, value);
        }

        /// <summary>
        /// Occurs when this <see cref="ItemContainer"/> is being dragged.
        /// </summary>
        public event EventHandler<DragEventArgs> DragDelta
        {
            add => AddHandler(DragDeltaEvent, value);
            remove => RemoveHandler(DragDeltaEvent, value);
        }

        /// <summary>
        /// Occurs when this <see cref="ItemContainer"/> completed the drag operation.
        /// </summary>
        public event EventHandler<DragEventArgs> DragCompleted
        {
            add => AddHandler(DragCompletedEvent, value);
            remove => RemoveHandler(DragCompletedEvent, value);
        }

        /// <summary>
        /// Occurs when this <see cref="ItemContainer"/> is selected.
        /// </summary>
        public event RoutedEventHandler Selected
        {
            add => AddHandler(SelectedEvent, value);
            remove => RemoveHandler(SelectedEvent, value);
        }

        /// <summary>
        /// Occurs when this <see cref="ItemContainer"/> is unselected.
        /// </summary>
        public event RoutedEventHandler Unselected
        {
            add => AddHandler(UnselectedEvent, value);
            remove => RemoveHandler(UnselectedEvent, value);
        }

        /// <summary>
        /// Raises the <see cref="LocationChangedEvent"/> and sets <see cref="IsPreviewingLocation"/> to false.
        /// </summary>
        protected void OnLocationChanged()
        {
            IsPreviewingLocation = false;
            RaiseEvent(new RoutedEventArgs(LocationChangedEvent, this));
        }

        /// <summary>
        /// Raises the <see cref="SelectedEvent"/> or <see cref="UnselectedEvent"/> based on <paramref name="newValue"/>.
        /// Called when the <see cref="IsSelected"/> value is changed.
        /// </summary>
        /// <param name="newValue">True if selected, false otherwise.</param>
        protected void OnSelectedChanged(bool newValue)
        {
            // Don't raise the event if the editor is selecting
            if (!Editor.IsSelecting)
            {
                RaiseEvent(new RoutedEventArgs(newValue ? SelectedEvent : UnselectedEvent, this));
            }
        }

        private static void OnIsSelectedChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            var elem = (ItemContainer)d;
            bool result = elem.IsSelectable && (bool)e.NewValue;
            elem.IsSelected = result;
            elem.OnSelectedChanged(result);
        }

        #endregion

        #region Fields

        /// <summary>
        /// Gets or sets whether cancelling a dragging operation is allowed.
        /// </summary>
        public static bool AllowDraggingCancellation { get; set; } = true;

        /// <summary>
        /// The <see cref="NodifyEditor"/> that owns this <see cref="ItemContainer"/>.
        /// </summary>
        public NodifyEditor Editor { get; }

        /// <summary>
        /// The calculated margin when the container is selected or previewing selection.
        /// </summary>
        public Thickness SelectedMargin => new Thickness(
            BorderThickness.Left - SelectedBorderThickness.Left,
            BorderThickness.Top - SelectedBorderThickness.Top,
            BorderThickness.Right - SelectedBorderThickness.Right,
            BorderThickness.Bottom - SelectedBorderThickness.Bottom);

        #endregion

        /// <summary>
        /// Occurs when the <see cref="ItemContainer"/> is previewing a new location.
        /// </summary>
        public event PreviewLocationChanged? PreviewLocationChanged;

        /// <summary>
        /// Raises the <see cref="PreviewLocationChanged"/> event and sets the <see cref="IsPreviewingLocation"/> property to true.
        /// </summary>
        /// <param name="newLocation">The new location.</param>
        protected internal void OnPreviewLocationChanged(Point newLocation)
        {
            IsPreviewingLocation = true;
            PreviewLocationChanged?.Invoke(newLocation);
        }

        static ItemContainer()
        {
            DefaultStyleKeyProperty.OverrideMetadata(typeof(ItemContainer), new FrameworkPropertyMetadata(typeof(ItemContainer)));
            SelectableMixin.Attach<ItemContainer>(IsSelectedProperty);
            PressedMixin.Attach<ItemContainer>();
            FocusableProperty.OverrideDefaultValue<ItemContainer>(true);
            LocationProperty.Changed.AddClassHandler<ItemContainer>(OnLocationChanged);
            IsSelectedProperty.OverrideMetadata<ItemContainer>(new StyledPropertyMetadata<bool>(false, BindingMode.TwoWay));
            IsSelectableProperty.Changed.AddClassHandler<ItemContainer>(OnIsSelectedChanged);
        }

        /// <summary>
        /// Constructs an instance of an <see cref="ItemContainer"/> in the specified <see cref="NodifyEditor"/>.
        /// </summary>
        /// <param name="editor"></param>
        public ItemContainer(NodifyEditor editor)
        {
            Editor = editor;
            _states.Push(GetInitialState());
            UpdatePseudoClasses();
        }

        protected override void OnApplyTemplate(TemplateAppliedEventArgs e)
        {
            base.OnApplyTemplate(e);

            State.Enter(null, null);
        }

        /// <inheritdoc />
        protected override void OnSizeChanged(SizeChangedInfo sizeInfo)
        {
            SetCurrentValue(ActualSizeProperty, sizeInfo.NewSize);
            base.OnSizeChanged(sizeInfo);
        }

        /// <summary>
        /// Checks if <paramref name="position"/> is selectable.
        /// </summary>
        /// <param name="position">A position relative to this <see cref="ItemContainer"/>.</param>
        /// <returns>True if <paramref name="position"/> is selectable.</returns>
        protected virtual bool IsSelectableLocation(Point position)
        {
            Size size = DesiredSizeForSelection ?? Bounds.Size;// RenderSize;
            return position.X >= 0 && position.Y >= 0 && position.X <= size.Width && position.Y <= size.Height;
        }

        /// <summary>
        /// Checks if <paramref name="area"/> contains or intersects with this <see cref="ItemContainer"/> taking into consideration the <see cref="DesiredSizeForSelection"/>.
        /// </summary>
        /// <param name="area">The area to check if contains or intersects this <see cref="ItemContainer"/>.</param>
        /// <param name="isContained">If true will check if <paramref name="area"/> contains this, otherwise will check if <paramref name="area"/> intersects with this.</param>
        /// <returns>True if <paramref name="area"/> contains or intersects this <see cref="ItemContainer"/>.</returns>
        public virtual bool IsSelectableInArea(Rect area, bool isContained)
        {
            var bounds = new Rect(Location, DesiredSizeForSelection ?? Bounds.Size /* RenderSize */);
            return isContained ? area.Contains(bounds) : area.Intersects(bounds);
        }

        #region State Handling

        private readonly Stack<ContainerState> _states = new Stack<ContainerState>();

        /// <summary>The current state of the container.</summary>
        public ContainerState State => _states.Peek();

        /// <summary>Creates the initial state of the container.</summary>
        /// <returns>The initial state.</returns>
        protected virtual ContainerState GetInitialState()
            => new ContainerDefaultState(this);

        /// <summary>Pushes the given state to the stack.</summary>
        /// <param name="state">The new state of the container.</param>
        /// <remarks>Calls <see cref="ContainerState.Enter"/> on the new state.</remarks>
        public void PushState(ContainerState state, MouseEventArgs? e)
        {
            var prev = State;
            _states.Push(state);
            state.Enter(prev, e);
        }

        /// <summary>Pops the current <see cref="State"/> from the stack.</summary>
        /// <remarks>It doesn't pop the initial state. (see <see cref="GetInitialState"/>)
        /// <br />Calls <see cref="ContainerState.Exit"/> on the current state.
        /// <br />Calls <see cref="ContainerState.ReEnter"/> on the previous state.
        /// </remarks>
        public void PopState()
        {
            // Never remove the default state
            if (_states.Count > 1)
            {
                ContainerState prev = _states.Pop();
                prev.Exit();
                State.ReEnter(prev);
            }
        }

        /// <summary>Pops all states from the container.</summary>
        /// <remarks>It doesn't pop the initial state. (see <see cref="GetInitialState"/>)</remarks>
        public void PopAllStates()
        {
            while (_states.Count > 1)
            {
                PopState();
            }
        }

        /// <inheritdoc />
        protected override void OnPointerPressed(PointerPressedEventArgs e)
        {
            if (IsSelectableLocation(e.GetPosition(this)))
            {
                Focus();

                e.Pointer.Capture(this);
                this.PropagateMouseCapturedWithin(true);

                State.HandleMouseDown(new MouseButtonEventArgs(e));
            }
        }

        /// <inheritdoc />
        protected override void OnPointerReleased(PointerReleasedEventArgs e)
        {
            if (IsSelectableLocation(e.GetPosition(this)) || ReferenceEquals(e.Pointer.Captured, this))
            {
                State.HandleMouseUp(new MouseButtonEventArgs(e));
            }

            // Release the mouse capture if all the mouse buttons are released
            if (ReferenceEquals(e.Pointer.Captured, this) && e.GetCurrentPoint(this).Properties is { IsLeftButtonPressed: false, IsMiddleButtonPressed: false, IsRightButtonPressed: false })
            {
                e.Pointer.Capture(null);
                this.PropagateMouseCapturedWithin(false);
            }
        }

        /// <inheritdoc />
        protected override void OnPointerMoved(PointerEventArgs e)
        {
            State.HandleMouseMove(new MouseMoveEventArgs(e));
        }

        /// <inheritdoc />
        protected override void OnPointerWheelChanged(PointerWheelEventArgs e)
        {
            State.HandleMouseWheel(new MouseWheelEventArgs());
        }

        /// <inheritdoc />
        protected override void OnPointerCaptureLost(PointerCaptureLostEventArgs e)
            => PopAllStates();

        protected override void OnKeyUp(KeyEventArgs e)
            => State.HandleKeyUp(e);

        protected override void OnKeyDown(KeyEventArgs e)
            => State.HandleKeyDown(e);

        #endregion
    }
}
